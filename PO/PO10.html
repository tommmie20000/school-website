<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PO10 - Fotos - Deel 1/2</title>
  <link rel="stylesheet" href="POstyles.css">
    <script src="https://unpkg.com/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script>
</head>
<body>
  <a href="../index.html" class="top-left-back-btn" title="Terug naar Home">&#8592;</a>
  <canvas id="starfield"></canvas>
  <main>
    <h1 class="title">PO10 - Fotos - Deel 1/2</h1>
    <div class="tags"><span>Foto's</span><span>Posering</span><span>Creativiteit</span></div>
    <img class="image" src="pics/PO10/bas1.jpg" alt="PO10 detail" style="overflow: hidden;">
    <p class="haslist">
     In de eerste les was er uitgelegd dat we fotos moesten gaan maken om te oefenen voor de grote opdracht. Elke les moesten we letten op een bepaalde factor, waaronder: <br>
     <b>1. Licht</b> - 6 proeffoto's<br>
     <b>2. Achtergrond/context</b> - 6 proeffoto's<br>
     <b>3. Houding en blik van de geportretteerde</b> - 6 proeffoto's<br>
     <b>4. Oogcontact</b> - 4 proeffoto's<br>
     <b>5. Kader/afsnijding</b> - 6 proeffoto's<br>
     <b>6. Emotie/verhaal</b> - 4 proeffoto's<br>
     <b>7. Relatie tussen de fotograaf en de geportretteerde</b> - 4 proeffoto's<br>
     <b>8. Inclusiviteit / diversiteit</b> - 6 proeffoto's<br>
     <br>
     Deze factoren zijn allemaal te zien in de fotos hieronder. Bij elke foto staat een beschrijving.    
    </p>
    <h2>Licht</h2>
            <!-- Image gallery box with arrows and captions -->
        <div class="gallery-box">
            <div class="gallery-counter" aria-hidden="true"><span class="current">1</span>/<span class="total">6</span></div>
        <button class="arrow left" aria-label="Previous">
          <svg width="20" height="20" viewBox="0 0 24 24"
               fill="none" stroke="white" stroke-width="2.5"
               stroke-linecap="round" stroke-linejoin="round">
            <polyline points="15 18 9 12 15 6"></polyline>
          </svg>
        </button>            
            <div class="image-slots">
                <figure class="slot active">
                    <img src="pics\PO10\20251201_094039.jpg" alt="Project view 1">
                    <figcaption>Kunstlicht, van de linkerkant. Dit geeft meer diepte op het profiel van het gezicht.</figcaption>
                </figure>
                <figure class="slot">
                    <img src="pics\PO10\20251201_095606.jpg" alt="Project view 2">
                    <figcaption>Kunstlicht, door de obstructies voor het licht en de donkerheid om het onderwerp heen behalve het belichtte gedeelte, geeft het een mooi effect.</figcaption>
                </figure>
                <figure class="slot">
                    <img src="pics/PO10/20250827_203217.jpg" alt="Project view 3">
                    <figcaption>Kunstlicht, lijkt een beetje natuurlijk. komt van de linker kant.</figcaption>
                </figure>
                <figure class="slot">
                    <img src="pics\PO10\20251022_163825.jpg" alt="Project view 4">
                    <figcaption>Natuurlijk licht, geeft diepte in het gezicht.</figcaption>
                </figure>
                <figure class="slot">
                    <img src="pics\PO10\20251201_094510(0).jpg" alt="Project view 5">
                    <figcaption>Kunstlicht, komt van de machine en boven.</figcaption>
                </figure>
                <figure class="slot">
                    <img src="pics/PO10/20251201_095900.jpg" alt="Project view 6">
                    <figcaption>Kunstlicht, van boven. dit geeft een machtig gevoel van het persoon. lijkt natuurlijk.</figcaption>
                </figure>
            </div>
            <button class="arrow right" aria-label="Next">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="9 18 15 12 9 6"></polyline>
                </svg>
            </button>
        </div>

    <h2>Achtergrond/context</h2>

    

<!--Back button-->
    <a href="../index.html" class="back-btn">‚Üê Terug naar Portfolio</a>
<!--End--> 

</main>

<script>
  mediumZoom('.image', {
    background: 'transparent',
    margin: 24 // optional: prevents edge-to-edge stretch
  })

    const canvas = document.getElementById('starfield');
    const ctx = canvas.getContext('2d');
    let w = canvas.width = window.innerWidth;
    let h = canvas.height = window.innerHeight;
    let stars = [];
    const STAR_COUNT = 400;

    // Glare settings
    const GLARE_COUNT = 6;
    let glares = [];

    // Flying stars settings
    const FLYING_STAR_INTERVAL = 20000; // ms
    const FLYING_STAR_SPEED = 7;
    const FLYING_STAR_LENGTH = 500;
    let flyingStars = [];

    function randomColor() {
        // Soft pastel colors for glare
        const hue = Math.floor(Math.random() * 360);
        return `hsla(${hue}, 70%, 80%, 0.06)`;
    }

    function initGlares() {
        glares = [];
        for (let i = 0; i < GLARE_COUNT; i++) {
            glares.push({
                x: Math.random() * w,
                y: Math.random() * h,
                r: Math.random() * 200 + 120,
                dx: (Math.random() - 0.5) * 0.2,
                dy: (Math.random() - 0.5) * 0.2,
                dr: (Math.random() - 0.5) * 0.1,
                color: randomColor()
            });
        }
    }

    function updateGlares() {
        for (let g of glares) {
            g.x += g.dx;
            g.y += g.dy;
            g.r += g.dr;
            // Bounce off edges
            if (g.x < 0 || g.x > w) g.dx *= -1;
            if (g.y < 0 || g.y > h) g.dy *= -1;
            if (g.r < 100 || g.r > 300) g.dr *= -1;
        }
    }

    function drawGlares() {
        for (let g of glares) {
            const grad = ctx.createRadialGradient(g.x, g.y, 0, g.x, g.y, g.r);
            grad.addColorStop(0, g.color);
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.globalAlpha = 1;
            ctx.beginPath();
            ctx.arc(g.x, g.y, g.r, 0, Math.PI * 2);
            ctx.fillStyle = grad;
            ctx.fill();
        }
    }

    function initStars() {
        stars = [];
        for (let i = 0; i < STAR_COUNT; i++) {
            stars.push({
                x: Math.random() * w,
                y: Math.random() * h,
                r: Math.random() * 1.5 + 0.5,
                baseR: 0, // for twinkle
                twinkleSpeed: Math.random() * 0.0005 + 0.0002,
                twinklePhase: Math.random() * Math.PI * 2
            });
        }
    }

    function drawStars() {
        ctx.clearRect(0, 0, w, h);
        drawGlares();
        ctx.save();
        ctx.fillStyle = 'white';
        ctx.beginPath();
        for (let s of stars) {
            // Twinkle: radius oscillates smoothly
            s.baseR = s.r + Math.sin(performance.now() * s.twinkleSpeed + s.twinklePhase) * 0.6;
            ctx.moveTo(s.x, s.y);
            ctx.arc(s.x, s.y, Math.max(0.2, s.baseR), 0, Math.PI * 2);
        }
        ctx.globalAlpha = 0.85;
        ctx.fill();
        ctx.restore();
        updateStars();
        updateGlares();
    }

    function updateStars() {
        for (let s of stars) {
            s.y += 0.08; // Slower movement (was 0.3)
            if (s.y > h) { s.x = Math.random() * w; s.y = 0; }
        }
    }

    // Flying stars logic
    function spawnFlyingStar() {
        // Random direction: left->right or right->left, random vertical position
        const dir = Math.random() < 0.5 ? 1 : -1;
        const y = Math.random() * h * 0.8 + h * 0.1;
        const x = dir === 1 ? -FLYING_STAR_LENGTH : w + FLYING_STAR_LENGTH;
        const angle = Math.random() * 0.3 - 0.15; // slight angle
        flyingStars.push({
            x, y,
            vx: (FLYING_STAR_SPEED * 0.2) * dir * Math.cos(angle), // Slower speed
            vy: (FLYING_STAR_SPEED * 0.3) * Math.sin(angle),       // Slower speed
            trail: [],
            maxTrail: 18,
            brightness: 1.0
        });
    }

    function updateFlyingStars() {
        for (let star of flyingStars) {
            // Move star
            star.x += star.vx;
            star.y += star.vy;
            // Add to trail
            star.trail.unshift({ x: star.x, y: star.y, alpha: 1 });
            if (star.trail.length > star.maxTrail) star.trail.pop();
        }
        // Remove stars out of bounds
        flyingStars = flyingStars.filter(star =>
            star.x > -FLYING_STAR_LENGTH && star.x < w + FLYING_STAR_LENGTH &&
            star.y > -FLYING_STAR_LENGTH && star.y < h + FLYING_STAR_LENGTH
        );
    }

    function drawFlyingStars() {
        for (let star of flyingStars) {
            // Draw trail
            for (let i = 0; i < star.trail.length - 1; i++) {
                const p1 = star.trail[i];
                const p2 = star.trail[i + 1];
                ctx.save();
                ctx.strokeStyle = `rgba(255,255,255,${0.7 * (1 - i / star.trail.length)})`;
                ctx.lineWidth = 2 - i * 1.5 / star.trail.length;
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
                ctx.restore();
            }
            // Draw star head
            ctx.save();
            ctx.globalAlpha = star.brightness;
            ctx.beginPath();
            ctx.arc(star.x, star.y, 3.5, 0, Math.PI * 2);
            ctx.fillStyle = 'white';
            ctx.shadowColor = 'white';
            ctx.shadowBlur = 16;
            ctx.fill();
            ctx.restore();
        }
    }

    function animate() {
        drawStars();
        drawFlyingStars();
        updateFlyingStars();
        requestAnimationFrame(animate);
    }

    initStars();
    initGlares();
    animate();

    // Flying stars timer
    let flyingStarTimer = setInterval(spawnFlyingStar, FLYING_STAR_INTERVAL);

    window.addEventListener('resize', () => {
        w = canvas.width = window.innerWidth;
        h = canvas.height = window.innerHeight;
        initStars();
        initGlares();
    });
</script>
<!-- Gallery navigation script -->
<script>
    (function(){
        const initGallery = () => {
            const gallery = document.querySelector('.gallery-box');
            if (!gallery) return;
            const slots = Array.from(gallery.querySelectorAll('.slot'));
            const left = gallery.querySelector('.arrow.left');
            const right = gallery.querySelector('.arrow.right');
            let idx = 0;

            function show(i) {
                idx = (i + slots.length) % slots.length;
                slots.forEach((s, j) => s.classList.toggle('active', j === idx));
                // update counter
                const counter = gallery.querySelector('.gallery-counter');
                if (counter) {
                    const currentEl = counter.querySelector('.current');
                    currentEl.textContent = String(idx + 1);
                    // animate a brief flash/pop
                    counter.classList.remove('flash');
                    void counter.offsetWidth;
                    counter.classList.add('flash');
                }
                // reposition arrows next to the visible image
                positionArrows();
                positionCaption();
            }

            left.addEventListener('click', () => show(idx - 1));
            right.addEventListener('click', () => show(idx + 1));

            // Enable medium-zoom on gallery images
            let zoomInstance = null;
            try{
                const galleryImgs = gallery.querySelectorAll('.slot img');
                if (galleryImgs.length) {
                    zoomInstance = mediumZoom(Array.from(galleryImgs), { background: 'rgba(0,0,0,0.85)', margin: 24 });
                    // when zoom opens, create a caption overlay for the zoomed image
                    if (zoomInstance && typeof zoomInstance.on === 'function'){
                        zoomInstance.on('open', ({target}) => {
                            const srcImg = target || document.querySelector('.medium-zoom-image--opened');
                            showZoomCaptionFor(srcImg);
                        });
                        zoomInstance.on('close', () => {
                            removeZoomCaption();
                        });
                    }
                }
            } catch (e) {
                // medium-zoom not available or error; silently ignore
            }

            // compute and set arrow positions so they sit next to the current image
            function positionArrows(){
                const leftArrow = gallery.querySelector('.arrow.left');
                const rightArrow = gallery.querySelector('.arrow.right');
                if (!leftArrow || !rightArrow) return;
                const active = gallery.querySelector('.slot.active');
                if (!active) return;
                const img = active.querySelector('img');
                if (!img) return;
                const gRect = gallery.getBoundingClientRect();
                const iRect = img.getBoundingClientRect();
                const arrowW = leftArrow.offsetWidth || 48;
                const gap = 8; // px gap between image and arrow
                // left arrow: place just to left of image
                let leftPos = iRect.left - gRect.left - arrowW - gap;
                // right arrow: place just to right of image
                let rightPos = iRect.left - gRect.left + iRect.width + gap;
                // clamp so arrows remain inside gallery box
                leftPos = Math.max(6, Math.min(leftPos, gRect.width - arrowW - 6));
                rightPos = Math.max(6, Math.min(rightPos, gRect.width - arrowW - 6));
                leftArrow.style.left = leftPos + 'px';
                rightArrow.style.left = rightPos + 'px';
                // vertically center to image center
                const topPos = (iRect.top - gRect.top) + (iRect.height / 2);
                leftArrow.style.top = topPos + 'px';
                rightArrow.style.top = topPos + 'px';
                // ensure transform preserves vertical centering
                leftArrow.style.transform = 'translateY(-50%)';
                rightArrow.style.transform = 'translateY(-50%)';
            }

            // position caption bubble so it fits within the visible image
            function positionArrows(){
                const leftArrow = gallery.querySelector('.arrow.left');
                const rightArrow = gallery.querySelector('.arrow.right');
                if (!leftArrow || !rightArrow) return;
            
                const active = gallery.querySelector('.slot.active');
                if (!active) return;
            
                const img = active.querySelector('img');
                if (!img) return;
            
                const gRect = gallery.getBoundingClientRect();
                const iRect = img.getBoundingClientRect();
            
                const arrowW = leftArrow.offsetWidth || 48;
                const gap = 8;
            
                let leftPos = iRect.left - gRect.left - arrowW - gap;
                let rightPos = iRect.left - gRect.left + iRect.width + gap;
            
                leftPos = Math.max(6, Math.min(leftPos, gRect.width - arrowW - 6));
                rightPos = Math.max(6, Math.min(rightPos, gRect.width - arrowW - 6));
            
                leftArrow.style.left = leftPos + 'px';
                rightArrow.style.left = rightPos + 'px';
            }


            // show caption for zoomed image by creating a fixed overlay element
            let _zoomCaptionEl = null;
            function showZoomCaptionFor(srcImg){
                removeZoomCaption();
                if (!srcImg) return;
                // find the original figure's caption text
                const orig = Array.from(gallery.querySelectorAll('.slot img')).find(i=>i.src === srcImg.src || i.getAttribute('data-zoom-src') === srcImg.src) || null;
                let text = '';
                if (orig) {
                    const fig = orig.closest('.slot');
                    const cap = fig && fig.querySelector('figcaption');
                    if (cap) text = cap.textContent.trim();
                }
                if (!text) return;
                _zoomCaptionEl = document.createElement('div');
                _zoomCaptionEl.className = 'medium-zoom-caption';
                _zoomCaptionEl.textContent = text;
                document.body.appendChild(_zoomCaptionEl);
                // position repeatedly for a short time to follow medium-zoom animation
                let frames = 0;
                function tick(){
                    positionZoomCaption();
                    frames++;
                    if (frames < 12 && _zoomCaptionEl) requestAnimationFrame(tick);
                }
                requestAnimationFrame(tick);
                // reposition while zoomed in on resize/scroll
                window.addEventListener('resize', positionZoomCaption);
                window.addEventListener('scroll', positionZoomCaption, true);
            }
            function removeZoomCaption(){
                if (_zoomCaptionEl){
                    _zoomCaptionEl.remove();
                    _zoomCaptionEl = null;
                    window.removeEventListener('resize', positionZoomCaption);
                    window.removeEventListener('scroll', positionZoomCaption, true);
                }
            }
            function positionZoomCaption(){
                if (!_zoomCaptionEl) return;
                const opened = document.querySelector('.medium-zoom-image--opened');
                if (!opened) return;
                const r = opened.getBoundingClientRect();
                // center caption horizontally and place near bottom of opened image
                _zoomCaptionEl.style.left = (r.left + r.width / 2) + 'px';
                // place caption above the bottom edge of the opened image
                const capH = _zoomCaptionEl.offsetHeight || 40;
                const topPos = (r.top + r.height) - capH - 18;
                _zoomCaptionEl.style.top = topPos + 'px';
                _zoomCaptionEl.style.transform = 'translate(-50%, 0)';
                _zoomCaptionEl.style.maxWidth = Math.max(120, r.width - 48) + 'px';
            }

            // reposition on resize and when images load
            window.addEventListener('resize', () => {
                requestAnimationFrame(positionArrows);
                requestAnimationFrame(positionCaption);
            });
            gallery.querySelectorAll('.slot img').forEach(img => img.addEventListener('load', ()=> {
                requestAnimationFrame(positionArrows);
                requestAnimationFrame(positionCaption);
            }));

            // keyboard support
            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft') show(idx - 1);
                if (e.key === 'ArrowRight') show(idx + 1);
            });
            // allow click on visible image to hint zoom: subtle scale on press
            gallery.addEventListener('pointerdown', (ev)=>{
                const img = ev.target.closest && ev.target.closest('.slot') && ev.target.closest('.slot').querySelector('img');
                if (!img) return;
                img.style.transform = 'scale(0.995)';
            });
            gallery.addEventListener('pointerup', (ev)=>{
                const img = ev.target.closest && ev.target.closest('.slot') && ev.target.closest('.slot').querySelector('img');
                if (!img) return;
                img.style.transform = '';
            });
            // ensure arrows and caption positioned on init (in case images were already cached)
            requestAnimationFrame(()=>{ positionArrows(); positionCaption(); });
            // extra attempt after layout settles
            setTimeout(()=>{ positionArrows(); positionCaption(); }, 120);
            // also position when entire window loads
            window.addEventListener('load', () => requestAnimationFrame(()=>{ positionArrows(); positionCaption(); }));
        };

        if (document.readyState !== 'loading') initGallery();
        else document.addEventListener('DOMContentLoaded', initGallery);
    })();
</script>
</body>
</html>