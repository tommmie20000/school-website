<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PO3 - Flatpack furniture - Comfortabele stoel</title>
  <link rel="stylesheet" href="POstyles.css">
</head>
<body>
  <a href="../index.html" class="top-left-back-btn" title="Terug naar Home">&#8592;</a>
  <canvas id="starfield"></canvas>
  <main>
    <h1 class="title">PO3 - Flatpack furniture - Comfortabele stoel</h1>
    <div class="tags"><span>CAD</span><span>3D Printing</span><span>Multimateriaal</span></div>
    <img class="image" src="pics/PO2/product2.jpg" alt="PO2 detail">

<!--Title-->
    <h2>Marktonderzoek + brainstorm</h2>
<!--End-->

<!--Paragraph-->
    <p>Ik begon mijn onderzoek door op Pinterest te zoeken naar 'flatpack furniture'. Al snel vond ik veel stoelen, banken en tafels in die stijl. Twee foto‚Äôs spraken me aan: een tafel met vier stoelen eraan vast, en een ligstoel met elastische banden voor comfort. Daarna maakte ik ontwerpen in Fusion360 zonder een specifiek materiaal te kiezen, zodat ik later de ontwerpen kon printen en op materialen plakken. Ik brainstormde met Lynden en Yonah (Dean hielp ook een beetje, maar wij deden het meeste). Uiteindelijk besloot ik een comfortabele ligstoel van hout te maken, ge√Ønspireerd door een houten stoel met zwarte banden. Ik koos hout omdat het goedkoop, makkelijk te bewerken en mooi is. Ook deed ik onderzoek naar stoelen voor ouderen, en kwam uit op lig- en verstelbare stoelen. Een nadeel van mijn stoel is dat hij laag is, wat lastig kan zijn voor mensen met rugklachten, maar ik zie het vooral als een comfortabele ligstoel.</p>
<!--End-->

<!--Image-->
    <img class="image" src="pics/PO3/1.png" alt="Ontwerpproces">
<!--End-->

<!--Image-->
    <img class="image" src="pics/PO3/2.png" alt="Ontwerpproces">
<!--End-->

<!--Title-->
    <h2>Vormstudies + Beginontwerpen</h2>
<!--End-->

<!--Paragraph-->
    <p>Ik had veel tijd besteed aan het maken van ontwerpen en het doen van onderzoek, waardoor ik wat later begon met het uitvoeren van de tests. Uiteindelijk heb ik de tests 3D-geprint (aanvankelijk was ik bezig met een houten versie, maar ik had thuis niet de juiste gereedschappen om die af te maken). Ik koos voor 3D-printen, vooral vanwege de complexe geometrie die moeilijk op schaal met de hand te maken is in vergelijking met printen. Hoewel dit misschien klinkt alsof ik hierdoor minder tijd in het project heb gestoken en 'lui' was, heb ik de tijd die ik niet aan het maken besteedde, juist gebruikt om het ontwerp verder te perfectioneren. Ik heb als 3 stoelen 2 krukken gemaakt, en 1 ligstoel (De ligstoel is uiteindelijk ook een beetje veranderd en het eindontwerp geworden.)</p>
<!--End-->

<!--Image-->
    <img class="image" src="pics/PO3/DSC00579.jpg" alt="Ontwerpproces">
<!--End-->

<!--Image-->
    <img class="image" src="pics/PO3/DSC00573.jpg" alt="Ontwerpproces">
<!--End-->

<!--Image-->
    <img class="image" src="pics/PO3/DSC00588.jpg" alt="Ontwerpproces">
<!--End-->

<!--Title-->
    <h2>Eindontwerp + Reflectie</h2>
<!--End-->

<!--Paragraph-->
    <p>Voor mijn eindontwerp heb ik een ligstoel 3D-geprint en vervolgens oud plastic materiaal gebruikt. Dit heb ik zo gesneden dat ik het kon buigen voor een mooie, afgeronde en vloeiende vorm. De verbindingen waren niet perfect ontworpen, waardoor ik wat lijm moest gebruiken om alles goed vast te krijgen. Maar als je erover nadenkt, is er bij een stoel met houtverbindingen ook een grote kans dat die niet goed blijft zitten zonder lijm (anders kan het na verloop van tijd losraken of gaan rammelen). Ik heb mijn best gedaan voor dit project en vond het leuk om te ontwerpen en idee√´n uit te wisselen. Wat ik wel jammer vind, is dat mijn Chromebook net te traag is om Fusion360 in de les te gebruiken en ik nog geen laptop mag kopen, omdat er nog veel kan veranderen tegen de tijd dat ik ga studeren. Ik denk dat ik het project ook zonder 3D-printen had kunnen afronden, maar door afleiding in de les kwam ik uiteindelijk in tijdsnood. Ook had ik de connecties wel wat beter kunnen makenüòÖ. Ter extra informatie, mijn eindontwerp was de ronddraaiende gif linksbovenin bij de fotos. !! Ik lever mijn houtverbindingen-onderzoek nog apart in !!</p>
<!--End-->

<!--Image-->
    <img class="image" src="pics/PO3/ezgif.com-effects.gif" alt="Ontwerpproces">
<!--End-->

<!--Title-->
    <h2>Brainstorm + houtonderzoek</h2>
<!--End-->

<!--Zooming image-->
    <img class="image" src="pics/PO3/houtonderzoek.png" alt="Ontwerpproces">
    <script src="https://unpkg.com/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script>
<!--End-->

<!--Zooming image-->
    <img class="image" src="pics/PO3/Screenshot 2024-10-16 190453.png" alt="Ontwerpproces">
    <script src="https://unpkg.com/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script>
<!--End-->

<!--Back button-->
    <a href="../index.html" class="back-btn">‚Üê Terug naar Portfolio</a>
<!--End--> 

</main>

<script>
    mediumZoom('.image', { background: 'transparent' })

    const canvas = document.getElementById('starfield');
    const ctx = canvas.getContext('2d');
    let w = canvas.width = window.innerWidth;
    let h = canvas.height = window.innerHeight;
    let stars = [];
    const STAR_COUNT = 400;

    // Glare settings
    const GLARE_COUNT = 6;
    let glares = [];

    // Flying stars settings
    const FLYING_STAR_INTERVAL = 20000; // ms
    const FLYING_STAR_SPEED = 7;
    const FLYING_STAR_LENGTH = 500;
    let flyingStars = [];

    function randomColor() {
        // Soft pastel colors for glare
        const hue = Math.floor(Math.random() * 360);
        return `hsla(${hue}, 70%, 80%, 0.06)`;
    }

    function initGlares() {
        glares = [];
        for (let i = 0; i < GLARE_COUNT; i++) {
            glares.push({
                x: Math.random() * w,
                y: Math.random() * h,
                r: Math.random() * 200 + 120,
                dx: (Math.random() - 0.5) * 0.2,
                dy: (Math.random() - 0.5) * 0.2,
                dr: (Math.random() - 0.5) * 0.1,
                color: randomColor()
            });
        }
    }

    function updateGlares() {
        for (let g of glares) {
            g.x += g.dx;
            g.y += g.dy;
            g.r += g.dr;
            // Bounce off edges
            if (g.x < 0 || g.x > w) g.dx *= -1;
            if (g.y < 0 || g.y > h) g.dy *= -1;
            if (g.r < 100 || g.r > 300) g.dr *= -1;
        }
    }

    function drawGlares() {
        for (let g of glares) {
            const grad = ctx.createRadialGradient(g.x, g.y, 0, g.x, g.y, g.r);
            grad.addColorStop(0, g.color);
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.globalAlpha = 1;
            ctx.beginPath();
            ctx.arc(g.x, g.y, g.r, 0, Math.PI * 2);
            ctx.fillStyle = grad;
            ctx.fill();
        }
    }

    function initStars() {
        stars = [];
        for (let i = 0; i < STAR_COUNT; i++) {
            stars.push({
                x: Math.random() * w,
                y: Math.random() * h,
                r: Math.random() * 1.5 + 0.5,
                baseR: 0, // for twinkle
                twinkleSpeed: Math.random() * 0.0005 + 0.0002,
                twinklePhase: Math.random() * Math.PI * 2
            });
        }
    }

    function drawStars() {
        ctx.clearRect(0, 0, w, h);
        drawGlares();
        ctx.save();
        ctx.fillStyle = 'white';
        ctx.beginPath();
        for (let s of stars) {
            // Twinkle: radius oscillates smoothly
            s.baseR = s.r + Math.sin(performance.now() * s.twinkleSpeed + s.twinklePhase) * 0.6;
            ctx.moveTo(s.x, s.y);
            ctx.arc(s.x, s.y, Math.max(0.2, s.baseR), 0, Math.PI * 2);
        }
        ctx.globalAlpha = 0.85;
        ctx.fill();
        ctx.restore();
        updateStars();
        updateGlares();
    }

    function updateStars() {
        for (let s of stars) {
            s.y += 0.08; // Slower movement (was 0.3)
            if (s.y > h) { s.x = Math.random() * w; s.y = 0; }
        }
    }

    // Flying stars logic
    function spawnFlyingStar() {
        // Random direction: left->right or right->left, random vertical position
        const dir = Math.random() < 0.5 ? 1 : -1;
        const y = Math.random() * h * 0.8 + h * 0.1;
        const x = dir === 1 ? -FLYING_STAR_LENGTH : w + FLYING_STAR_LENGTH;
        const angle = Math.random() * 0.3 - 0.15; // slight angle
        flyingStars.push({
            x, y,
            vx: (FLYING_STAR_SPEED * 0.2) * dir * Math.cos(angle), // Slower speed
            vy: (FLYING_STAR_SPEED * 0.3) * Math.sin(angle),       // Slower speed
            trail: [],
            maxTrail: 18,
            brightness: 1.0
        });
    }

    function updateFlyingStars() {
        for (let star of flyingStars) {
            // Move star
            star.x += star.vx;
            star.y += star.vy;
            // Add to trail
            star.trail.unshift({ x: star.x, y: star.y, alpha: 1 });
            if (star.trail.length > star.maxTrail) star.trail.pop();
        }
        // Remove stars out of bounds
        flyingStars = flyingStars.filter(star =>
            star.x > -FLYING_STAR_LENGTH && star.x < w + FLYING_STAR_LENGTH &&
            star.y > -FLYING_STAR_LENGTH && star.y < h + FLYING_STAR_LENGTH
        );
    }

    function drawFlyingStars() {
        for (let star of flyingStars) {
            // Draw trail
            for (let i = 0; i < star.trail.length - 1; i++) {
                const p1 = star.trail[i];
                const p2 = star.trail[i + 1];
                ctx.save();
                ctx.strokeStyle = `rgba(255,255,255,${0.7 * (1 - i / star.trail.length)})`;
                ctx.lineWidth = 2 - i * 1.5 / star.trail.length;
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
                ctx.restore();
            }
            // Draw star head
            ctx.save();
            ctx.globalAlpha = star.brightness;
            ctx.beginPath();
            ctx.arc(star.x, star.y, 3.5, 0, Math.PI * 2);
            ctx.fillStyle = 'white';
            ctx.shadowColor = 'white';
            ctx.shadowBlur = 16;
            ctx.fill();
            ctx.restore();
        }
    }

    function animate() {
        drawStars();
        drawFlyingStars();
        updateFlyingStars();
        requestAnimationFrame(animate);
    }

    initStars();
    initGlares();
    animate();

    // Flying stars timer
    let flyingStarTimer = setInterval(spawnFlyingStar, FLYING_STAR_INTERVAL);

    window.addEventListener('resize', () => {
        w = canvas.width = window.innerWidth;
        h = canvas.height = window.innerHeight;
        initStars();
        initGlares();
    });
</script>
</body>
</html>