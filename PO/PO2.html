<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PO2 - Giveaway Keychain Fidget</title>
  <link rel="stylesheet" href="POstyles.css">
</head>
<body>
  <a href="../index.html" class="top-left-back-btn" title="Terug naar Home">&#8592;</a>
  <canvas id="starfield"></canvas>
  <main>
    <h1 class="title">PO2 - Giveaway Keychain Fidget</h1>
    <div class="tags"><span>CAD</span><span>3D Printing</span></div>
    <img class="image" src="pics/PO2/product2.jpg" alt="PO2 detail">

<!--Title-->
    <h2>Marktonderzoek + brainstorm</h2>
<!--End-->

<!--Paragraph-->
    <p>Ik begon mijn marktonderzoek door na te denken over wat kinderen in groep 8 van de basisschool leuk vinden. Later gebruikte ik dit als basis om mijn zoektocht te vereenvoudigen. Ik kwam allerlei ideeën tegen, zoals fidget spinners, sleutelhangers en andere leuke items, maar niets sprong er echt uit. Dus besloot ik in mijn kamer rond te kijken en kreeg ik ineens een goed idee. Een paar maanden geleden had ik namelijk van mijn sponsor PCBWay een schroevendraaier gekregen (zie foto), met een ratchet-mechanisme en verschillende handige functies. Vooral dat ratchet-mechanisme trok mijn aandacht, dus ging ik op Makerworld verder op zoek naar inspiratie. Uiteindelijk vond ik precies wat ik zocht. In de bijgevoegde brainstorm zie je ook dat ik steeds meer naar fidget toys neigde. Ik wilde namelijk iets maken dat kinderen niet meteen zouden weggooien, maar dat ze bijvoorbeeld aan hun sleutels konden hangen en mee konden spelen als ze zich verveelden. Daarom dacht ik dat een simpele sleutelhanger met bijvoorbeeld het Jan van Brabant-logo erop snel in de prullenbak zou belanden, omdat het niet echt nuttig is. Ik heb mijn ontwerp daarna uitgebreid getest bij mijn vrienden, en zij vonden het allemaal vrij leuk en interessant om mee te spelen.</p>
<!--End-->

<!--Image-->
    <img class="image" src="pics/PO2/product5.jpg" alt="Schroevendraaier">
<!--End-->

<!--Title-->
    <h2>Schets + ontwerp</h2>
<!--End-->

<!--Paragraph-->
    <p>Normaal maak ik bijna nooit een schets en begin ik meteen met het ontwerp, waarna ik zie hoe het gaat. Ik heb dan een idee in mijn hoofd, wat je misschien een soort 'mentale schets' kunt noemen, en dat werk ik vaak vanzelf uit in Fusion360 en later in het echte ontwerp. Voor dit project heb ik wel op een paar dingen gelet die erin moesten. Ik wilde een S-vormige veer maken van 0,8 mm breed (omdat de nozzle 0,4 mm is, wat zorgt voor een veer die niet te moeilijk in te drukken is, maar ook niet te snel kapot gaat). De as waar het wiel op zat, was ook een uitdaging, want het moest soepel kunnen draaien én goed te printen zijn. Eerst had ik een V-vorm gemaakt (twee keer een 'V' in elkaar, waarbij de onderkant van de V vastzat aan het lichaam, zie in de foto's hieronder). Maar het printte niet goed, en het wiel kwam vast te zitten aan het lichaam. Daarom heb ik de vorm veranderd naar een rechthoek, en nu draait het wiel soepel en werkt het goed.</p>
<!--End-->

<!--Image-->
    <img class="image" src="pics/PO2/product6.png" alt="Ontwerpproces">
<!--End-->

<!--Image-->
    <img class="image" src="pics/PO2/product7.png" alt="Ontwerpproces">
<!--End-->
<!--Title-->
    <h2>Reflectie</h2>
<!--End-->

<!--Paragraph-->
    <p>Ik vond dit een leuk project om te maken en heb er wel wat van geleerd (niet heel veel), zoals dat PETG het beste materiaal is om veren mee te printen, hoe je een 3D-geprinte 'bearing' het beste kunt maken en hoe je ontwerpen kunt optimaliseren voor print-in-place. Ik ben tevreden met het eindresultaat en hoop zeker dat het gekozen wordt voor de giveaway.</p>
<!--End-->

<!--Title-->
    <h2>Mindmap</h2>
<!--End-->

<!--Zooming image-->
    <img class="image" src="pics/PO2/mindmap.jpg" alt="Ontwerpproces">
    <script src="https://unpkg.com/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script>
<!--End-->

<!--Back button-->
    <a href="../index.html" class="back-btn">← Terug naar Portfolio</a>
<!--End--> 

</main>

<script>
    mediumZoom('.image', { background: 'transparent' })

    const canvas = document.getElementById('starfield');
    const ctx = canvas.getContext('2d');
    let w = canvas.width = window.innerWidth;
    let h = canvas.height = window.innerHeight;
    let stars = [];
    const STAR_COUNT = 400;

    // Glare settings
    const GLARE_COUNT = 6;
    let glares = [];

    // Flying stars settings
    const FLYING_STAR_INTERVAL = 20000; // ms
    const FLYING_STAR_SPEED = 7;
    const FLYING_STAR_LENGTH = 500;
    let flyingStars = [];

    function randomColor() {
        // Soft pastel colors for glare
        const hue = Math.floor(Math.random() * 360);
        return `hsla(${hue}, 70%, 80%, 0.06)`;
    }

    function initGlares() {
        glares = [];
        for (let i = 0; i < GLARE_COUNT; i++) {
            glares.push({
                x: Math.random() * w,
                y: Math.random() * h,
                r: Math.random() * 200 + 120,
                dx: (Math.random() - 0.5) * 0.2,
                dy: (Math.random() - 0.5) * 0.2,
                dr: (Math.random() - 0.5) * 0.1,
                color: randomColor()
            });
        }
    }

    function updateGlares() {
        for (let g of glares) {
            g.x += g.dx;
            g.y += g.dy;
            g.r += g.dr;
            // Bounce off edges
            if (g.x < 0 || g.x > w) g.dx *= -1;
            if (g.y < 0 || g.y > h) g.dy *= -1;
            if (g.r < 100 || g.r > 300) g.dr *= -1;
        }
    }

    function drawGlares() {
        for (let g of glares) {
            const grad = ctx.createRadialGradient(g.x, g.y, 0, g.x, g.y, g.r);
            grad.addColorStop(0, g.color);
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.globalAlpha = 1;
            ctx.beginPath();
            ctx.arc(g.x, g.y, g.r, 0, Math.PI * 2);
            ctx.fillStyle = grad;
            ctx.fill();
        }
    }

    function initStars() {
        stars = [];
        for (let i = 0; i < STAR_COUNT; i++) {
            stars.push({
                x: Math.random() * w,
                y: Math.random() * h,
                r: Math.random() * 1.5 + 0.5,
                baseR: 0, // for twinkle
                twinkleSpeed: Math.random() * 0.0005 + 0.0002,
                twinklePhase: Math.random() * Math.PI * 2
            });
        }
    }

    function drawStars() {
        ctx.clearRect(0, 0, w, h);
        drawGlares();
        ctx.save();
        ctx.fillStyle = 'white';
        ctx.beginPath();
        for (let s of stars) {
            // Twinkle: radius oscillates smoothly
            s.baseR = s.r + Math.sin(performance.now() * s.twinkleSpeed + s.twinklePhase) * 0.6;
            ctx.moveTo(s.x, s.y);
            ctx.arc(s.x, s.y, Math.max(0.2, s.baseR), 0, Math.PI * 2);
        }
        ctx.globalAlpha = 0.85;
        ctx.fill();
        ctx.restore();
        updateStars();
        updateGlares();
    }

    function updateStars() {
        for (let s of stars) {
            s.y += 0.08; // Slower movement (was 0.3)
            if (s.y > h) { s.x = Math.random() * w; s.y = 0; }
        }
    }

    // Flying stars logic
    function spawnFlyingStar() {
        // Random direction: left->right or right->left, random vertical position
        const dir = Math.random() < 0.5 ? 1 : -1;
        const y = Math.random() * h * 0.8 + h * 0.1;
        const x = dir === 1 ? -FLYING_STAR_LENGTH : w + FLYING_STAR_LENGTH;
        const angle = Math.random() * 0.3 - 0.15; // slight angle
        flyingStars.push({
            x, y,
            vx: (FLYING_STAR_SPEED * 0.2) * dir * Math.cos(angle), // Slower speed
            vy: (FLYING_STAR_SPEED * 0.3) * Math.sin(angle),       // Slower speed
            trail: [],
            maxTrail: 18,
            brightness: 1.0
        });
    }

    function updateFlyingStars() {
        for (let star of flyingStars) {
            // Move star
            star.x += star.vx;
            star.y += star.vy;
            // Add to trail
            star.trail.unshift({ x: star.x, y: star.y, alpha: 1 });
            if (star.trail.length > star.maxTrail) star.trail.pop();
        }
        // Remove stars out of bounds
        flyingStars = flyingStars.filter(star =>
            star.x > -FLYING_STAR_LENGTH && star.x < w + FLYING_STAR_LENGTH &&
            star.y > -FLYING_STAR_LENGTH && star.y < h + FLYING_STAR_LENGTH
        );
    }

    function drawFlyingStars() {
        for (let star of flyingStars) {
            // Draw trail
            for (let i = 0; i < star.trail.length - 1; i++) {
                const p1 = star.trail[i];
                const p2 = star.trail[i + 1];
                ctx.save();
                ctx.strokeStyle = `rgba(255,255,255,${0.7 * (1 - i / star.trail.length)})`;
                ctx.lineWidth = 2 - i * 1.5 / star.trail.length;
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
                ctx.restore();
            }
            // Draw star head
            ctx.save();
            ctx.globalAlpha = star.brightness;
            ctx.beginPath();
            ctx.arc(star.x, star.y, 3.5, 0, Math.PI * 2);
            ctx.fillStyle = 'white';
            ctx.shadowColor = 'white';
            ctx.shadowBlur = 16;
            ctx.fill();
            ctx.restore();
        }
    }

    function animate() {
        drawStars();
        drawFlyingStars();
        updateFlyingStars();
        requestAnimationFrame(animate);
    }

    initStars();
    initGlares();
    animate();

    // Flying stars timer
    let flyingStarTimer = setInterval(spawnFlyingStar, FLYING_STAR_INTERVAL);

    window.addEventListener('resize', () => {
        w = canvas.width = window.innerWidth;
        h = canvas.height = window.innerHeight;
        initStars();
        initGlares();
    });
</script>
</body>
</html>